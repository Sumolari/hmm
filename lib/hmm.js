// Generated by CoffeeScript 1.10.0

/*
A Hidden Markov Model implementation in Javascript.
 */

(function() {
  var HMM,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  HMM = (function() {

    /*
    Constructs a new Hidden Markov Model. All parameters are optional.
    
    @param [Array<String>] states States of the model.
    @param [String] finalState Final state of the model.
    @param [Array<String>] symbols Symbols of the model.
    @param [Dict<String,Float>] initialProbability
    Initial Probability of the model.
    @param [Dict<String, Dict<String, Float>>] transitionProbability
    Transition Probability of the model.
    @param [Dict<String, Dict<String, Float>>] emissionProbability
    Emission Probability of the model.
    @return [HMM] New Hidden Markov Model.
     */
    function HMM(states, finalState, symbols1, initialProbability, transitionProbability, emissionProbability) {
      this.states = states != null ? states : [];
      this.finalState = finalState != null ? finalState : '';
      this.symbols = symbols1 != null ? symbols1 : [];
      this.initialProbability = initialProbability != null ? initialProbability : {};
      this.transitionProbability = transitionProbability != null ? transitionProbability : {};
      this.emissionProbability = emissionProbability != null ? emissionProbability : {};
    }


    /*
    Returns the initial probability of given state.
    @private
    
    @param [String] state State whose initial probability will be retrieved.
    @return [Float] Probability that the initial state is given one.
     */

    HMM.prototype.ip = function(state) {
      var ref;
      return (ref = this.initialProbability[state]) != null ? ref : 0;
    };


    /*
    Returns the probability of moving from given source state to given destination
    state.
    @private
    
    @param [String] source Initial state.
    @param [String] target Destination state.
    @return [Float] Probability of moving from given initial state to given
    destination state.
     */

    HMM.prototype.tp = function(source, target) {
      var ref, ref1;
      return (ref = (ref1 = this.transitionProbability[source]) != null ? ref1[target] : void 0) != null ? ref : 0;
    };


    /*
    Returns the probability that given state emits given symbol.
    @private
    
    @param [String] state State that will be emitting the symbol.
    @param [String] symbol Symbol that should be emitted.
    @return [Float] Probability that given state emits given symbol.
     */

    HMM.prototype.ep = function(state, symbol) {
      var ref, ref1;
      return (ref = (ref1 = this.emissionProbability[state]) != null ? ref1[symbol] : void 0) != null ? ref : 0;
    };


    /*
    Returns a printable string with this model's information.
    
    @return [String] Printable string with this model's information.
     */

    HMM.prototype.toString = function() {
      var k, l, len, len1, len2, len3, len4, len5, len6, m, o, p, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, source, state, str, symbol, target;
      str = 'A\t';
      ref = this.states;
      for (k = 0, len = ref.length; k < len; k++) {
        state = ref[k];
        str += state + "\t";
      }
      str += '\n';
      ref1 = this.states;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        source = ref1[l];
        str += source + "\t";
        ref2 = this.states;
        for (m = 0, len2 = ref2.length; m < len2; m++) {
          target = ref2[m];
          str += (this.tp(source, target)) + "\t";
        }
        str += '\n';
      }
      str += '\nB\t';
      ref3 = this.symbols;
      for (o = 0, len3 = ref3.length; o < len3; o++) {
        symbol = ref3[o];
        str += symbol + "\t";
      }
      str += '\n';
      ref4 = this.states;
      for (p = 0, len4 = ref4.length; p < len4; p++) {
        state = ref4[p];
        if (state === this.finalState) {
          continue;
        }
        str += state + "\t";
        ref5 = this.symbols;
        for (q = 0, len5 = ref5.length; q < len5; q++) {
          symbol = ref5[q];
          str += (this.ep(state, symbol)) + "\t";
        }
        str += '\n';
      }
      str += '\nInitial:\n';
      ref6 = this.states;
      for (r = 0, len6 = ref6.length; r < len6; r++) {
        state = ref6[r];
        str += state + ":\t" + (this.ip(state)) + "\n";
      }
      str += "\nFinal: " + this.finalState;
      return str;
    };


    /*
    Prints a representation of this model.
     */

    HMM.prototype.print = function() {
      return console.log(this.toString());
    };


    /*
    Reestimates this model to properly classify given obversed sequences.
    
    @param [Array<String>] items Items used to reestimate this model.
    @param [Array<String>] path Optional. Array of optimal paths for each one of
    given items. If no paths are given they are computed with Viterbi algorithm.
     */

    HMM.prototype.reestimate = function(items, paths) {
      var base, base1, base2, base3, count, dst, head, index, initials, item, j, k, l, len, len1, len2, m, name, o, original, path, ref, ref1, results, shouldRepeat, source, src, state, sum, symbol, symbol_count, symbols, target, transition, transition_count, transitions;
      shouldRepeat = true;
      results = [];
      while (shouldRepeat) {
        initials = {};
        transitions = {};
        symbols = {};
        original = {
          st: this.states,
          sy: this.symbols,
          fs: this.finalState,
          ip: this.initialProbability,
          tp: JSON.stringify(this.transitionProbability),
          ep: JSON.stringify(this.emissionProbability)
        };
        if (paths == null) {
          paths = [];
          for (k = 0, len = items.length; k < len; k++) {
            item = items[k];
            paths.push(this.viterbi(item).path);
          }
        }
        this.transitionProbability = {};
        this.emissionProbability = {};
        for (l = 0, len1 = paths.length; l < len1; l++) {
          path = paths[l];
          head = path[0];
          if (initials[head] == null) {
            initials[head] = 0;
          }
          initials[head]++;
        }
        for (state in initials) {
          count = initials[state];
          this.initialProbability[state] = count / paths.length;
        }
        sum = {};
        for (index = m = 0, len2 = paths.length; m < len2; index = ++m) {
          path = paths[index];
          item = items[index];
          for (j = o = 0, ref = path.length - 1; 0 <= ref ? o < ref : o > ref; j = 0 <= ref ? ++o : --o) {
            source = path[j];
            target = path[j + 1];
            if (sum[source] == null) {
              sum[source] = 0;
            }
            sum[source]++;
            if (transitions[source] == null) {
              transitions[source] = {};
            }
            if ((base = transitions[source])[target] == null) {
              base[target] = 0;
            }
            transitions[source][target]++;
            if (symbols[source] == null) {
              symbols[source] = {};
            }
            if ((base1 = symbols[source])[name = item[j]] == null) {
              base1[name] = 0;
            }
            symbols[source][item[j]]++;
          }
        }
        for (src in transitions) {
          transition = transitions[src];
          for (dst in transition) {
            transition_count = transition[dst];
            if ((base2 = this.transitionProbability)[src] == null) {
              base2[src] = {};
            }
            this.transitionProbability[src][dst] = transition_count / sum[src];
          }
          ref1 = symbols[src];
          for (symbol in ref1) {
            symbol_count = ref1[symbol];
            if ((base3 = this.emissionProbability)[src] == null) {
              base3[src] = {};
            }
            this.emissionProbability[src][symbol] = symbol_count / sum[src];
          }
        }
        results.push(shouldRepeat = original.st !== this.states || original.sy !== this.symbols || original.ip !== this.initialProbability || original.tp !== JSON.stringify(this.transitionProbability || original.ep !== JSON.stringify(this.emissionProbability)));
      }
      return results;
    };


    /*
    Initializes this model with given items.
    
    @param [Array<String>] items Items used to reestimate this model.
    @param [Integer] n Number of states to use in this model.
     */

    HMM.prototype.initialize = function(items, n) {
      var i, j, k, l, len, len1, len2, m, o, path, paths, ref, sequence, symbol;
      paths = [];
      this.symbols = [];
      this.states = (function() {
        var k, ref, results;
        results = [];
        for (i = k = 1, ref = n; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
          results.push("" + i);
        }
        return results;
      })();
      this.finalState = 'F';
      this.states.push(this.finalState);
      for (k = 0, len = items.length; k < len; k++) {
        sequence = items[k];
        for (l = 0, len1 = sequence.length; l < len1; l++) {
          symbol = sequence[l];
          if (indexOf.call(this.symbols, symbol) < 0) {
            this.symbols.push(symbol);
          }
        }
      }
      for (m = 0, len2 = items.length; m < len2; m++) {
        sequence = items[m];
        path = [];
        for (j = o = 1, ref = sequence.length; 1 <= ref ? o <= ref : o >= ref; j = 1 <= ref ? ++o : --o) {
          path.push("" + (1 + Math.floor(j * n / (sequence.length + 1))));
        }
        path.push(this.finalState);
        paths.push(path);
      }
      return this.reestimate(items, paths);
    };


    /*
    Returns the Viterbi approximation to the probability of this model generating
    given item using the fastest implementation available.
    
    @param [Array<String>] item Item whose generation probability will be returned.
    @return [Float] Viterbi approximation to the probability of this markov model
    generating given item.
     */

    HMM.prototype.viterbiApproximation = function(item) {
      return this.viterbi(item).probability;
    };


    /*
    Returns most probable sequence of states generating given item (if any).
    
    @param [Array<String>] item Item whose optimal state sequence will be returned.
    @return [Array<String>] Optimal state sequence generating given item.
    If given item can't be generate undefined is returned.
     */

    HMM.prototype.optimalStateSequence = function(item) {
      return this.viterbi(item).path;
    };


    /*
    Returns the Viterbi approximation to the probability of this model generating
    given item.
    
    @param [Array<String>] item Item whose generation probability will be returned.
    @return [Object] Viterbi approximation to the probability of this markov model
    generating given item: an object with a `probability` and a `path` key.
     */

    HMM.prototype.viterbi = function(item) {
      var V, calc, k, l, len, len1, len2, len3, len4, m, max, newpath, o, p, path, q, ref, ref1, ref2, ref3, ref4, ref5, ref6, source, state, t, target, tep;
      V = [{}];
      path = {};
      ref = this.states;
      for (k = 0, len = ref.length; k < len; k++) {
        state = ref[k];
        V[0][state] = this.ip(state) * this.ep(state, item[0]);
        path[state] = [state];
      }
      for (t = l = 1, ref1 = item.length; 1 <= ref1 ? l < ref1 : l > ref1; t = 1 <= ref1 ? ++l : --l) {
        V.push({});
        newpath = {};
        ref2 = this.states;
        for (m = 0, len1 = ref2.length; m < len1; m++) {
          target = ref2[m];
          max = [0, null];
          ref3 = this.states;
          for (o = 0, len2 = ref3.length; o < len2; o++) {
            source = ref3[o];
            tep = this.tp(source, target) * this.ep(target, item[t]);
            calc = V[t - 1][source] * tep;
            if (calc >= max[0]) {
              max = [calc, source];
            }
          }
          V[t][target] = max[0];
          newpath[target] = path[max[1]].concat(target);
        }
        path = newpath;
      }
      V.push({});
      newpath = {};
      max = [0, null];
      ref4 = this.states;
      for (p = 0, len3 = ref4.length; p < len3; p++) {
        source = ref4[p];
        calc = V[t - 1][source] * this.tp(source, this.finalState);
        if (calc >= max[0]) {
          max = [calc, source];
        }
      }
      V[item.length][this.finalState] = max[0];
      path[this.finalState] = path[max[1]].concat(this.finalState);
      max = [0, null];
      ref5 = this.states;
      for (q = 0, len4 = ref5.length; q < len4; q++) {
        state = ref5[q];
        calc = (ref6 = V[item.length][state]) != null ? ref6 : 0;
        if (calc >= max[0]) {
          max = [calc, state];
        }
      }
      return {
        probability: parseFloat(max[0].toFixed(6)),
        path: path[max[1]]
      };
    };


    /*
    Returns the real probability of this model generating given item.
    @private
    
    @param [Array<String>] item Item whose generation probability will be returned.
    @param [String] state Optional. Initial state for computation. If no state is
    given then all of them will be taken into account.
    @return [Float] Real probability of this markov model generating given item.
     */

    HMM.prototype.forwardProbability = function(item, state) {
      var getSequenceProbability, iep, k, len, probability, ref, rest, symbol;
      symbol = item[0];
      rest = item.slice(1);
      probability = 0;
      getSequenceProbability = (function(_this) {
        return function(source, sequence) {
          var k, len, ref, target, tpfp, tpp;
          if (sequence.length === 0) {
            return _this.tp(source, _this.finalState);
          }
          probability = 0;
          ref = _this.states;
          for (k = 0, len = ref.length; k < len; k++) {
            target = ref[k];
            tpp = _this.tp(source, target);
            tpfp = _this.forwardProbability(sequence, target);
            probability += tpp * tpfp;
          }
          return probability;
        };
      })(this);
      if (state == null) {
        ref = this.states;
        for (k = 0, len = ref.length; k < len; k++) {
          state = ref[k];
          iep = this.ep(state, symbol) * this.ip(state);
          if (iep > 0) {
            probability += iep * getSequenceProbability(state, rest);
          }
        }
      } else {
        probability = this.ep(state, symbol) * getSequenceProbability(state, rest);
      }
      return parseFloat(probability.toFixed(6));
    };


    /*
    Returns the probability that given item is generated by this model.
    Note that this method is much more expensive than the Viterbi Approximation
    and the results are similar.
    
    @param [Array<String>] item Item whose generation probability will be returned.
    @return [Float] Probability that this model generates given item.
     */

    HMM.prototype.generationProbability = function(item) {
      return this.forwardProbability(item);
    };

    return HMM;

  })();

  module.exports = HMM;

}).call(this);
